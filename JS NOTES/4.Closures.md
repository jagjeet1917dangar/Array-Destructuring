# JavaScript – Closures, Lexical Environment & Higher-Order Functions

---

## 1. Understanding Closures: Functions with Preserved Data Scope

* Closure ek **function + uska surrounding data (scope)** hota hai.
* Jab ek function dusre function ke andar likha hota hai aur **inner function parent ke variables ko use karta hai**, tab closure banta hai.
* Even jab parent function execute ho chuka hota hai, tab bhi inner function ko uske variables yaad rehte hain.

Example:

```js
function outer() {
    let count = 0;
    function inner() {
        count++;
        console.log(count);
    }
    return inner;
}

const counter = outer();
counter(); // 1
counter(); // 2
```

* yaha `outer()` ke khatam hone ke baad bhi `inner()` ko `count` yaad hai — ye hi **closure** ka power hai.

---

## 2. Lexical Environment: How Closures Capture Variables

* Har function ke saath ek **lexical environment** hota hai jisme wo function ke local variables + parent ke scope ka reference store hota hai.
* Jab JS engine kisi variable ko nahi paata function ke andar, wo parent ke lexical scope me jaata hai.

Example:

```js
function a() {
    let x = 10;
    function b() {
        console.log(x); // access from parent scope
    }
    b();
}
a();
```

* yaha `b()` ke paas apna lexical environment hai jisme `x` ka reference stored hai.
* isi concept ke base pe closure kaam karta hai.

---

## 3. Practical Applications of Closures

Closures sirf theory nahi, kaafi jagah use hota hai real code me:

### a) Data Privacy

```js
function bankAccount() {
    let balance = 1000;
    return {
        deposit(amount) {
            balance += amount;
            console.log("Balance:", balance);
        },
        withdraw(amount) {
            balance -= amount;
            console.log("Balance:", balance);
        }
    };
}

const account = bankAccount();
account.deposit(500);  // Balance: 1500
account.withdraw(300); // Balance: 1200
```

* yaha `balance` private hai — bahar se directly access nahi kar sakte.

### b) Event Handlers / setTimeout

```js
function greet(name) {
    setTimeout(() => {
        console.log("Hello " + name);
    }, 2000);
}
greet("Jagjeet");
```

* `setTimeout` ke andar bhi closure banta hai jo `name` ko preserve karta hai.

### c) Function Factories

```js
function makeAdder(x) {
    return function(y) {
        return x + y;
    };
}

const add5 = makeAdder(5);
console.log(add5(10)); // 15
```

* ye closure based function generator ka example hai.

---

## 4. Higher-Order Functions (HOF) Definition

* **Higher-Order Function** wo function hota hai jo:

  * ek function ko **argument** ke roop me leta hai, ya
  * ek function **return** karta hai.

Example:

```js
function greetUser(greetFn) {
    greetFn("Hello from HOF");
}

function printMsg(msg) {
    console.log(msg);
}

greetUser(printMsg);
```

* yaha `greetUser` ek HOF hai kyunki ye ek function ko parameter ke form me le raha hai.

JS me common HOFs: `map()`, `filter()`, `reduce()`, `forEach()`

---

## 5. Method Chaining with Higher-Order Functions

* Method chaining ka matlab hai ek ke baad ek function call karna, jahan har function ek **object ya array** return kare taaki next method usi pe call ho sake.

Example:

```js
let arr = [1, 2, 3, 4, 5];

let result = arr
    .filter(n => n % 2 === 0)
    .map(n => n * 10)
    .reduce((acc, val) => acc + val, 0);

console.log(result); // 60
```

Step-by-step:

1. `filter()` → even numbers `[2, 4]`
2. `map()` → multiply by 10 → `[20, 40]`
3. `reduce()` → sum all → `60`

* har function ek naya array return karta hai, isliye chaining possible hoti hai.

---

### Recap:

* **Closure:** function + preserved scope
* **Lexical Environment:** variable reference system
* **Use Cases:** data privacy, event handlers, function factories
* **HOF:** takes or returns another function
* **Chaining:** multiple HOF calls in sequence

---

**Note:** Closures initially tricky lagte hain, but once samajh gaye to JS ka poora behavior crystal clear ho jaata hai.
