# Asynchronous JavaScript

Asynchronous JavaScript basically means â€” JS code **doesnâ€™t wait** for one task to finish before moving to the next.
It lets multiple things happen *side by side*, especially when dealing with **APIs, timers, or file loading**.

For example â€” jaise hi ek image load ho rahi hai, JS dusra kaam bhi continue karta hai, bina rukhe.
This is possible because JS runs in a **single thread**, but handles async tasks using **Event Loop** and **Web APIs**.

---

## What are Callback Functions?

A **callback function** is a function passed as an **argument** to another function,
and it is executed *after* that function finishes its task.

Example:

```js
function greet(name, callback) {
    console.log("Hi " + name);
    callback();
}
function sayBye() {
    console.log("Bye!");
}
greet("Jagjeet", sayBye);
```

Here `sayBye` runs **after** `greet()` executes â€” thatâ€™s a callback!

Simple samjho â€” callback ek â€œfunction ke andar function callâ€ hai jo baad mein execute hota hai.

---

## Understanding setTimeout and setInterval

**setTimeout()**: Runs a function **after** a given delay (in milliseconds).
**setInterval()**: Repeats a function **every** given time interval.

Example:

```js
setTimeout(() => {
    console.log("Runs after 2 seconds");
}, 2000);

setInterval(() => {
    console.log("Runs every 1 second");
}, 1000);
```

Soch lo setTimeout ek baar ka alarm hai â°
Aur setInterval ek baar chalu hone ke baad baar-baar bajta hai ðŸ˜…

---

## The JavaScript Event Loop

Event Loop ek **core mechanism** hai jo JS ko asynchronous banata hai.
It checks if the **Call Stack** is empty and then pushes **callback functions** from the **Callback Queue** into the stack to be executed.

**Flow samjho:**

1. JS code runs line by line (single thread)
2. Async functions (like `setTimeout`) are sent to **Web APIs**
3. Once done, their callback goes to the **Callback Queue**
4. Event Loop checks â€” if stack is free, then executes the queued callbacks

Simple line: *Event Loop ensures non-blocking code execution.*

---

## Web APIs and Browser Environment

When you use functions like:

* `setTimeout`
* `fetch`
* `DOM events` (like `click`, `scroll`)

...these donâ€™t actually run in JS Engine.
They run in **Web APIs** provided by the **browser environment**,
and when theyâ€™re done, callbacks are sent back to JS via **Event Loop**.

So JS + Browser milke asynchronous behavior achieve karte hain.

---

## Callback Hell and Solutions

When multiple callbacks are nested inside each other,
the code becomes messy, hard to read, and debug â€” this is called **Callback Hell**.

Example:

```js
getData(function(data1) {
  getMoreData(data1, function(data2) {
    getEvenMoreData(data2, function(data3) {
      console.log("Done!");
    });
  });
});
```

Dekha? Yeh pyramid jaisa structure ban gaya ðŸ˜©
Itâ€™s confusing and difficult to manage.

**Solutions:**

1. **Promises** â€“ cleaner way to handle async operations
2. **Async/Await** â€“ syntactic sugar over Promises, makes code look synchronous

Example using Promises:

```js
getData()
  .then(getMoreData)
  .then(getEvenMoreData)
  .then(() => console.log("Done!"))
  .catch(err => console.log(err));
```

Example using Async/Await:

```js
async function fetchData() {
  try {
    const data1 = await getData();
    const data2 = await getMoreData(data1);
    console.log("Done!");
  } catch (err) {
    console.log(err);
  }
}
```

Much cleaner! Aur samajhne mein bhi easy ðŸ˜Ž

---

**Summary:**

* Async JS = non-blocking execution
* Event Loop + Web APIs = async power
* Callbacks are foundation but can cause hell
* Promises & async/await = modern clean approach

*(End of Notes â€” likhte likhte yaad bhi ho gaya ðŸ˜…)*
